##函数简介
    函数也是一个对象

    def fun(s,*f): #f 参数把多余调用的统一保存在一个元组中


    带*参数后的所有参数必须以关键字参数形式传递

如果形参的开头直接写一个*，则要求我们所有的参数必须以关键字参数形式传递
 def fn2(*,a,b,c)

#参数解包（拆包）
def fn4(a,b,c,d):
    print(a,b,c,d)
   

 t=(1,2,3,4)
 fn4(*t)
 t2 = {'a':21,'b':32,'c':12,'d':32}
 fn4(**t2)

 返回值 可以是任务类型的对象

help 函数 使用说明(doc str)


#文档字符串，

#命名与作用域
函数外部定义的变量是全局作用域

命名空间
每个作用域都会有一个对应的命名空间
locals() #当前的命名空间 【字典】

globals() #返回全局命名空间

递归：
1、基线条件 【满足此条件循环将不在执行】
2、递归条件【将问题继续分解执行的条件】

高阶函数 :gaojie.py

接收函数做为参数或是将函数返回值 的函数是高阶函数


匿名函数：
(lambda a,b:a+b)(1,2)

闭包
1、有函数 嵌套
2、将内容部函数作为返回值 返回
3、内部函数必须要使用到外部函数的变量

`装饰器`
ocp开闭原则
#装饰器函数

def begin_end(old):
    def new_function(*args,**kwargs):
        print("开始执行~~~~")

        result= old(*args,**kwargs)

        print("执行结束")
        return result
    return new_function

#当前的函数被装饰了
@begin_end
@func
def say_hello():
    print("大家好")

say_hello()

多个装饰器，由内向外执行,例如上面先执行func函数

类变量（Class Variable）是共享的（Shared）——它们可以被属于该类的所有实例访问。该类变量只拥有一个副本，当任何一个对象对类变量作出改变时，发生的变动将在其它所有实例中都会得到体现。

所有的类成员都是公开的。但有一个例外：如果你使用数据成员并在其名字中使用双下划线作为前缀，形成诸如 __privatevar 这样的形式，Python 会使用名称调整（Name-mangling）来使其有效地成为一个私有变量。
因此，你需要遵循这样的约定：任何在类或对象之中使用的变量其命名应以下划线开头，其它所有非此格式的名称都将是公开的，并可以为其它任何类或对象所使用。请记得这只是一个约定，Python 并不强制如此（除了双下划线前缀这点）。


###继承未完=======================
它是如何工作的
要想使用继承，在定义类6时我们需要在类后面跟一个包含基类名称的元组。然后，我们会注意到基类的 __init__ 方法是通过 self 变量被显式调用的，因此我们可以初始化对象的基类部分。下面这一点很重要，需要牢记——因为我们在 Teacher 和 Student 子类中定义了 __init__ 方法，Python 不会自动调用基类 SchoolMember 的构造函数，你必须自己显式地调用它


相反，如果我们没有在一个子类中定义一个 __init__ 方法，Python 将会自动调用基类的构造函数。[**]

这里有一条有关术语的注释——如果继承元组（Inheritance Tuple）中有超过一个类，这种情况就会被称作多重继承（Multiple Inheritance）。
end 参数用在超类的 tell() 方法的 print 函数中，目的是打印一行并允许下一次打印在同一行继续。这是一个让 print 能够不在打印的末尾打印出 \n （新行换行符）符号的小窍门。



